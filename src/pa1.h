//
//  pa1.h
//  header for pa1.cpp 
//
//  Created by Alejandro Santacoloma on 2/12/17.
//  COP3503 Programming 2 with C++
//
//
//
//  Copyright Â© 2017 Alejandro Santacoloma. All rights reserved.
//

#ifndef pa1_h
#define pa1_h


// magic square generated by this program is odd and between 3 and 15

// Constructing magic square using Siamese method also known as De la Loubere method,
// a simple method to construct any n odd sized magic square.
// Perfect for this assignment due to constraint of odd numbered magic square of size n between 3 and 15


// Algorithm consists of starting with 1 and using arithmetic progression in an orderly pattern,
// each algorithm has a basic move pattern and an exception move which are as follow

// First square algorithm, start at first row, middle column, follows right and up pattern, if space filled then left once and down twice

// Second square algorithm, start at middle row, last column, follows right and up pattern, if space filled then left twice and down once

// Third square algorithm, start at middle row first column follows left and down pattern, if space filled then right twice and up once

// Fourth square algorithm, start at last row, middle column, follows left and down pattern, if space filled then right once and up twice


void squaremagic(int type, int size)
{
    
    
    //initialze magicsquare
    int magicsq[15][15] = {0};
    
    int bstep = 0;
    int bjump = 0;
    int estep = 0;
    int ejump = 0;
    int row   = 0;
    int col   = 0;
    
    
    if(type == 1){
        //initialize steps and jumps
        bjump = -1;//up 1
        bstep =  1;//right 1
        ejump =  2;//down 2
        estep = -1;//left 1
        
        
        //intialize row and column variables
        row = 0;
        col = (size/2);
        
        //seed magic square with 1;
        magicsq[row][col] = 1;
    }
    else if(type == 2){
        
        //initialize steps and jumps
        bjump = -1;//up 1
        bstep =  1;//right 1
        ejump =  1;//down 1
        estep = -2;//left 2
        
        
        
        //intialize row and column variables
        row = (size/2);
        col = size-1;
        
        //seed magic square with 1;
        magicsq[row][col] = 1;
    }
    else if(type == 3){
        
        //initialize steps and jumps
        bjump =  1;//down 1
        bstep = -1;//left 1
        ejump = -1;//up 1
        estep =  2;//right 2
        
        //intialize row and column variables
        row = (size/2);
        col = (0);
        
        //seed magic square with 1;
        magicsq[row][col] = 1;
    }
    else if(type == 4){
        //initialize steps and jumps
        bjump =   1;//down 1
        bstep =  -1;//left 1
        ejump =  -2;//up 2
        estep =  +1;//right 1
        
        //intialize row and column variables
        row = size-1;
        col = (size/2);
        
        //seed magic square with 1;
        magicsq[row][col] = 1;
    }
    
    
    
    //start filling square
    for(int value = 2; value<=(size*size); value++)
    {
        
        //basicmove
        
        //row manipulation
        //if statements to prevent overindexing of rows
        if(row + bjump < size && row + bjump >= 0)
        {
            row = row + bjump;
        }
        else if(row + bjump == size)
        {
            row = 0;
        }
        else if(row + bjump > size)
        {
            row = 1;
        }
        else if(row + bjump == -1)
        {
            row = size - 1;
        }
        else if(row + bjump < -1)
        {
            row = size - 2;
        }
        
        //column manipulation
        if(col + bstep < size && col + bstep >=0)
        {
            col = col + bstep;
        }
        else if (col + bstep == -1)
        {
            col = size - 1;
        }
        else if (col + bstep < -1)
        {
            col = size - 2;
        }
        else if (col+ bstep == size)
        {
            col = 0;
        }
        else if (col+ bstep > size)
        {
            col = 1;
        }
        
        //if an empty spot was found, it is replaced with current number in loop
        if (magicsq[row][col] == 0)
        {
            magicsq[row][col] = value;
        }
        else
        {//else a while loop is initiated to use emove (alternative move used when a found spot is already filled
            bool move = false;
            
            
            //emove aka emergency move if spot already full
            while(move==false)
            {
                
                //row manipulation
                //if statements to prevent overindexing of rows
                if(row + ejump < size && row + ejump >= 0)
                {
                    row = row + ejump;
                }
                else if(row + ejump > size)
                {
                    row = 1;
                }
                else if(row + ejump == size)
                {
                    row = 0;
                }
                else if(row + ejump == -1)
                {
                    row = size - 1;
                }
                else if(row + ejump < -1)
                {
                    row = size - 2;
                }
                
                //column manipulation
                //if statements to prevent overindexing of columns
                if(col + estep < size && col + estep >=0)
                {
                    col = col + estep;
                }
                else if (col + estep == -1)
                {
                    col = size -1;
                }
                else if (col + estep < -1)
                {
                    col = size -2;
                }
                else if (col + estep == size)
                {
                    col = 0;
                }
                else if (col + estep > size)
                {
                    col = 1;
                }
                
                if (magicsq[row][col] == 0)
                {
                    magicsq[row][col] = value;
                    move = true;
                }
                else
                {
                    move = false;
                }
            }
        }
    }
    
    //end of for loop making square
    
    //testing of square begins
    
    //print array
    
    std::cout<<"\nMagic Square #"<< type <<" is:\n\n";
    for(int r = 0; r < size; r++ )
    {
        for(int c = 0; c < size; c++ )
        {
            std::cout<<magicsq[r][c]<<" ";
        }
        std::cout<<"\n";
    }
    
    //calculate sum goal value or the sum the square should output
    
    int sumgoal = ((((size*size) +1 )/2)*size);
    
    //row tester
    std::cout<<"\nOUTPUT>>"<<"Checking the sums of every row:     ";
    for(int testrow = 0; testrow<size; testrow++)
    {
        int sum = 0;
        for(int testcol = 0; testcol < size; testcol++)
        {
            sum = sum + magicsq[testrow][testcol];
            
        }
        std::cout<<sum<<" ";
        if (sum != sumgoal)
        {
            std::cout<<"wrong sum";
            
        }
       
    }
    
    //col tester
    std::cout<<"\nOUTPUT>>"<<"Checking the sums of every column:  ";
    for(int testcol = 0; testcol < size; testcol++)
    {
        int sum = 0;
        for(int testrow = 0; testrow<size; testrow++)
        {
            sum = sum + magicsq[testrow][testcol];
        }
        std::cout<<sum<<" ";
        if (sum != sumgoal)
        {
            std::cout<<"wrong sum";
        }
    }
    
    //diagonol tester
    std::cout<<"\nOUTPUT>>"<<"Checking the sums of every diagonal:";
    
    //left diagonol test
    int sumL = 0;
    for(int testdiagL = 0; testdiagL < size; testdiagL++)
    {
        sumL = sumL + magicsq[testdiagL][testdiagL];
    }
    std::cout<<sumL<<" ";
    if (sumL != sumgoal)
    {
        std::cout<<"wrong sum";
    }
    
    //right diagonol test
    
    int sumR = 0;
    int i    = 0;
    
    for(int testdiagR = size-1; testdiagR >= 0; testdiagR--)
    {
        sumR = sumR + magicsq[i][testdiagR];
    }
    
    std::cout<<sumR<<" \n";
    if (sumR != sumgoal)
    {
        std::cout<<"wrong sum";
    }
    
}



#endif /* pa1_h */